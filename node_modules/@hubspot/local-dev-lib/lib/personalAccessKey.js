"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateConfigWithPersonalAccessKey = exports.accessTokenForPersonalAccessKey = exports.getAccessToken = void 0;
const moment_1 = __importDefault(require("moment"));
const environments_1 = require("../constants/environments");
const auth_1 = require("../constants/auth");
const standardErrors_1 = require("../errors/standardErrors");
const localDevAuth_1 = require("../api/localDevAuth");
const sandboxHubs_1 = require("../api/sandboxHubs");
const config_1 = require("../config");
const i18nKey = 'lib.personalAccessKey';
const refreshRequests = new Map();
function getRefreshKey(personalAccessKey, expiration) {
    return `${personalAccessKey}-${expiration || 'fresh'}`;
}
async function getAccessToken(personalAccessKey, env = environments_1.ENVIRONMENTS.PROD, accountId) {
    let response;
    try {
        response = await (0, localDevAuth_1.fetchAccessToken)(personalAccessKey, env, accountId);
    }
    catch (e) {
        const error = e;
        if (error.response) {
            (0, standardErrors_1.throwAuthErrorWithMessage)(`${i18nKey}.errors.invalidPersonalAccessKey`, { errorMessage: error.response.data.message || '' }, error);
        }
        else {
            (0, standardErrors_1.throwError)(e);
        }
    }
    return {
        portalId: response.hubId,
        accessToken: response.oauthAccessToken,
        expiresAt: (0, moment_1.default)(response.expiresAtMillis).toISOString(),
        scopeGroups: response.scopeGroups,
        encodedOAuthRefreshToken: response.encodedOAuthRefreshToken,
    };
}
exports.getAccessToken = getAccessToken;
async function refreshAccessToken(personalAccessKey, env = environments_1.ENVIRONMENTS.PROD, accountId) {
    const { accessToken, expiresAt } = await getAccessToken(personalAccessKey, env, accountId);
    const config = (0, config_1.getAccountConfig)(accountId);
    (0, config_1.updateAccountConfig)({
        env,
        ...config,
        accountId,
        tokenInfo: {
            accessToken,
            expiresAt: expiresAt,
        },
    });
    (0, config_1.writeConfig)();
    return accessToken;
}
async function getNewAccessToken(accountId, personalAccessKey, expiresAt, env) {
    const key = getRefreshKey(personalAccessKey, expiresAt);
    if (refreshRequests.has(key)) {
        return refreshRequests.get(key);
    }
    let accessToken;
    try {
        const refreshAccessPromise = refreshAccessToken(personalAccessKey, env, accountId);
        if (key) {
            refreshRequests.set(key, refreshAccessPromise);
        }
        accessToken = await refreshAccessPromise;
    }
    catch (e) {
        if (key) {
            refreshRequests.delete(key);
        }
        throw e;
    }
    return accessToken;
}
async function accessTokenForPersonalAccessKey(accountId) {
    const account = (0, config_1.getAccountConfig)(accountId);
    if (!account) {
        (0, standardErrors_1.throwErrorWithMessage)(`${i18nKey}.errors.accountNotFound`, { accountId });
    }
    const { auth, personalAccessKey, env } = account;
    const authTokenInfo = auth && auth.tokenInfo;
    const authDataExists = authTokenInfo && auth?.tokenInfo?.accessToken;
    if (!authDataExists ||
        (0, moment_1.default)().add(5, 'minutes').isAfter((0, moment_1.default)(authTokenInfo.expiresAt))) {
        return getNewAccessToken(accountId, personalAccessKey, authTokenInfo && authTokenInfo.expiresAt, env);
    }
    return auth?.tokenInfo?.accessToken;
}
exports.accessTokenForPersonalAccessKey = accessTokenForPersonalAccessKey;
// Adds an account to the config using authType: personalAccessKey
const updateConfigWithPersonalAccessKey = async (personalAccessKey, env, name, makeDefault = false) => {
    const accountEnv = env || (0, config_1.getEnv)(name);
    let token;
    try {
        token = await getAccessToken(personalAccessKey, accountEnv);
    }
    catch (err) {
        (0, standardErrors_1.throwError)(err);
    }
    const { portalId, accessToken, expiresAt } = token;
    let hubInfo;
    try {
        hubInfo = await (0, sandboxHubs_1.fetchSandboxHubData)(accessToken, portalId, accountEnv);
    }
    catch (err) {
        // Ignore error, returns 404 if account is not a sandbox
    }
    let sandboxAccountType = null;
    let parentAccountId = null;
    if (hubInfo) {
        if (hubInfo.type !== undefined) {
            sandboxAccountType = hubInfo.type === null ? 'STANDARD' : hubInfo.type;
        }
        if (hubInfo.parentHubId) {
            parentAccountId = hubInfo.parentHubId;
        }
    }
    const updatedConfig = (0, config_1.updateAccountConfig)({
        accountId: portalId,
        personalAccessKey,
        name,
        authType: auth_1.PERSONAL_ACCESS_KEY_AUTH_METHOD.value,
        tokenInfo: { accessToken, expiresAt },
        sandboxAccountType,
        parentAccountId,
    });
    (0, config_1.writeConfig)();
    if (makeDefault && name) {
        (0, config_1.updateDefaultAccount)(name);
    }
    return updatedConfig;
};
exports.updateConfigWithPersonalAccessKey = updateConfigWithPersonalAccessKey;
