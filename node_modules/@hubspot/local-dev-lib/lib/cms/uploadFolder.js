"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasUploadErrors = exports.uploadFolder = exports.getFilesByType = void 0;
const path_1 = __importDefault(require("path"));
const p_queue_1 = __importDefault(require("p-queue"));
const handleFieldsJS_1 = require("./handleFieldsJS");
const fileMapper_1 = require("../fileMapper");
const fileMapper_2 = require("../../api/fileMapper");
const modules_1 = require("../../utils/cms/modules");
const escapeRegExp_1 = require("../../utils/escapeRegExp");
const logger_1 = require("../../utils/logger");
const path_2 = require("../path");
const standardErrors_1 = require("../../errors/standardErrors");
const apiErrors_1 = require("../../errors/apiErrors");
const logger_2 = require("../../utils/logger");
const files_1 = require("../../constants/files");
const i18nKey = 'lib.cms.uploadFolder';
const queue = new p_queue_1.default({
    concurrency: 10,
});
function getFileType(filePath) {
    const extension = (0, path_2.getExt)(filePath);
    const moduleFolder = (0, modules_1.isModuleFolderChild)({ path: filePath, isLocal: true });
    if (moduleFolder)
        return files_1.FILE_TYPES.module;
    switch (extension) {
        case 'js':
        case 'css':
            return files_1.FILE_TYPES.cssAndJs;
        case 'html':
            return files_1.FILE_TYPES.template;
        case 'json':
            return files_1.FILE_TYPES.json;
        default:
            return files_1.FILE_TYPES.other;
    }
}
async function getFilesByType(filePaths, projectDir, rootWriteDir, commandOptions) {
    const { convertFields, fieldOptions } = commandOptions;
    const projectDirRegex = new RegExp(`^${(0, escapeRegExp_1.escapeRegExp)(projectDir)}`);
    const fieldsJsObjects = [];
    // Create object with key-value pairs of form { FileType.type: [] }
    const filePathsByType = Object.values(files_1.FILE_TYPES).reduce((acc, fileType) => {
        return {
            ...acc,
            [fileType]: [],
        };
    }, {});
    for (const filePath of filePaths) {
        const fileType = getFileType(filePath);
        const relPath = filePath.replace(projectDirRegex, '');
        if (!convertFields) {
            filePathsByType[fileType].push(filePath);
            continue;
        }
        const convertableFields = (0, handleFieldsJS_1.isConvertableFieldJs)(projectDir, filePath, convertFields);
        if (convertableFields) {
            const rootOrModule = path_1.default.dirname(relPath) === '/' ? files_1.FILE_TYPES.json : files_1.FILE_TYPES.module;
            const fieldsJs = await new handleFieldsJS_1.FieldsJs(projectDir, filePath, rootWriteDir, fieldOptions).init();
            /*
             * A fields.js will be rejected if the promise is rejected or if the some other error occurs.
             * We handle this gracefully by not adding the failed fields.js to the object list.
             */
            if (fieldsJs.rejected)
                continue;
            fieldsJsObjects.push(fieldsJs);
            filePathsByType[rootOrModule].push(fieldsJs.outputPath || '');
        }
        else {
            filePathsByType[fileType].push(filePath);
        }
    }
    return [filePathsByType, fieldsJsObjects];
}
exports.getFilesByType = getFilesByType;
const uploadFolderCallbackKeys = ['success'];
async function uploadFolder(accountId, src, dest, fileMapperOptions, commandOptions = {}, filePaths = [], mode = null, logCallbacks) {
    const logger = (0, logger_2.makeTypedLogger)(logCallbacks);
    const { saveOutput, convertFields } = commandOptions;
    const tmpDir = convertFields
        ? (0, handleFieldsJS_1.createTmpDirSync)('hubspot-temp-fieldsjs-output-')
        : null;
    const regex = new RegExp(`^${(0, escapeRegExp_1.escapeRegExp)(src)}`);
    const apiOptions = (0, fileMapper_1.getFileMapperQueryValues)(mode, fileMapperOptions);
    const failures = [];
    let fieldsJsPaths = [];
    let tmpDirRegex;
    const [filesByType, fieldsJsObjects] = await getFilesByType(filePaths, src, tmpDir, commandOptions);
    const fileList = Object.values(filesByType);
    if (fieldsJsObjects.length) {
        fieldsJsPaths = fieldsJsObjects.map(fieldsJs => {
            return { outputPath: fieldsJs.outputPath, filePath: fieldsJs.filePath };
        });
        tmpDirRegex = new RegExp(`^${(0, escapeRegExp_1.escapeRegExp)(tmpDir || '')}`);
    }
    function uploadFile(file) {
        const fieldsJsFileInfo = fieldsJsPaths.find(f => f.outputPath === file);
        const originalFilePath = fieldsJsFileInfo
            ? fieldsJsFileInfo.filePath
            : file;
        // files in fieldsJsPaths always belong to the tmp directory.
        const relativePath = file.replace(fieldsJsFileInfo ? tmpDirRegex : regex, '');
        const destPath = (0, path_2.convertToUnixPath)(path_1.default.join(dest, relativePath));
        return async () => {
            (0, logger_1.debug)(`${i18nKey}.uploadFolder.attempt`, {
                file: originalFilePath || '',
                destPath,
            });
            try {
                await (0, fileMapper_2.upload)(accountId, file, destPath, apiOptions);
                logger('success', `${i18nKey}.uploadFolder.success`, {
                    file: originalFilePath || '',
                    destPath,
                });
            }
            catch (err) {
                const error = err;
                if ((0, standardErrors_1.isFatalError)(error)) {
                    throw error;
                }
                (0, logger_1.debug)(`${i18nKey}.uploadFolder.failed`, { file, destPath });
                if (error.response && error.response.data) {
                    console.debug(error.response.data);
                }
                else {
                    console.debug(error.message);
                }
                failures.push({
                    file,
                    destPath,
                });
            }
        };
    }
    for (let i = 0; i < fileList.length; i++) {
        const filesToUpload = fileList[i];
        await queue.addAll(filesToUpload.map(uploadFile));
    }
    const results = await queue
        .addAll(failures.map(({ file, destPath }) => {
        return async () => {
            (0, logger_1.debug)(`${i18nKey}.uploadFolder.retry`, { file, destPath });
            try {
                await (0, fileMapper_2.upload)(accountId, file, destPath, apiOptions);
                logger('success', `${i18nKey}.uploadFolder.success`, {
                    file,
                    destPath,
                });
                return {
                    resultType: files_1.FILE_UPLOAD_RESULT_TYPES.SUCCESS,
                    error: null,
                    file,
                };
            }
            catch (err) {
                (0, logger_1.debug)(`${i18nKey}.uploadFolder.retryFailed`, { file, destPath });
                const error = err;
                if ((0, standardErrors_1.isFatalError)(error)) {
                    throw error;
                }
                (0, apiErrors_1.throwApiUploadError)(error, {
                    accountId,
                    request: destPath,
                    payload: file,
                });
            }
        };
    }))
        .finally(() => {
        if (!convertFields)
            return;
        if (saveOutput) {
            fieldsJsObjects.forEach(fieldsJs => fieldsJs.saveOutput());
        }
        (0, handleFieldsJS_1.cleanupTmpDirSync)(tmpDir || '');
    });
    return results;
}
exports.uploadFolder = uploadFolder;
function hasUploadErrors(results) {
    return results.some(result => result.resultType === files_1.FILE_UPLOAD_RESULT_TYPES.FAILURE);
}
exports.hasUploadErrors = hasUploadErrors;
