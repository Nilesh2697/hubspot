"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadFileOrFolder = exports.fetchFolderFromApi = exports.writeUtimes = exports.recurseFolder = exports.getTypeDataFromPath = exports.getFileMapperQueryValues = exports.isPathToHubspot = exports.isPathToRoot = exports.isPathToModule = exports.isPathToFile = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const p_queue_1 = __importDefault(require("p-queue"));
const path_2 = require("./path");
const fileMapper_1 = require("../api/fileMapper");
const standardErrors_1 = require("../errors/standardErrors");
const extensions_1 = require("../constants/extensions");
const files_1 = require("../constants/files");
const fileSystemErrors_1 = require("../errors/fileSystemErrors");
const logger_1 = require("../utils/logger");
const i18nKey = 'lib.fileMapper';
const queue = new p_queue_1.default({
    concurrency: 10,
});
function isPathToFile(filepath) {
    const ext = (0, path_2.getExt)(filepath);
    return !!ext && ext !== extensions_1.MODULE_EXTENSION && ext !== extensions_1.FUNCTIONS_EXTENSION;
}
exports.isPathToFile = isPathToFile;
function isPathToModule(filepath) {
    const ext = (0, path_2.getExt)(filepath);
    return ext === extensions_1.MODULE_EXTENSION;
}
exports.isPathToModule = isPathToModule;
function isPathToRoot(filepath) {
    if (typeof filepath !== 'string')
        return false;
    // Root pattern matches empty strings and: / \
    return /^(\/|\\)?$/.test(filepath.trim());
}
exports.isPathToRoot = isPathToRoot;
function isPathToHubspot(filepath) {
    if (typeof filepath !== 'string')
        return false;
    return /^(\/|\\)?@hubspot/i.test(filepath.trim());
}
exports.isPathToHubspot = isPathToHubspot;
function useApiBuffer(mode) {
    return mode === files_1.MODE.draft;
}
// Determines API param based on mode an options
function getFileMapperQueryValues(mode, { staging, assetVersion } = {}) {
    return {
        params: {
            buffer: useApiBuffer(mode),
            environmentId: staging ? 2 : 1,
            version: assetVersion,
        },
    };
}
exports.getFileMapperQueryValues = getFileMapperQueryValues;
// Determines version number to log based on input.options
function getAssetVersionIdentifier(assetVersion, src) {
    if (typeof assetVersion !== 'undefined' &&
        typeof src !== 'undefined' &&
        src.startsWith('@hubspot/')) {
        return ` v${assetVersion}`;
    }
    return '';
}
function validateFileMapperNode(node) {
    if (node === Object(node))
        return;
    let json;
    try {
        json = JSON.stringify(node, null, 2);
    }
    catch (err) {
        json = node;
    }
    (0, standardErrors_1.throwTypeErrorWithMessage)(`${i18nKey}.errors.invalidNode`, {
        json: JSON.stringify(json),
    });
}
function getTypeDataFromPath(src) {
    const isModule = isPathToModule(src);
    const isHubspot = isPathToHubspot(src);
    const isFile = !isModule && isPathToFile(src);
    const isRoot = !isModule && !isFile && isPathToRoot(src);
    const isFolder = !isFile;
    return {
        isModule,
        isHubspot,
        isFile,
        isRoot,
        isFolder,
    };
}
exports.getTypeDataFromPath = getTypeDataFromPath;
function recurseFolder(node, callback, filepath = '', depth = 0) {
    validateFileMapperNode(node);
    const isRootFolder = node.folder && depth === 0;
    if (isRootFolder) {
        if (!filepath) {
            filepath = node.name;
        }
    }
    else {
        filepath = path_1.default.join(filepath, node.name);
    }
    let __break = callback(node, filepath, depth);
    if (__break === false)
        return __break;
    __break = node.children.every(childNode => {
        __break = recurseFolder(childNode, callback, filepath, depth + 1);
        return __break !== false;
    });
    return depth === 0 ? false : __break;
}
exports.recurseFolder = recurseFolder;
async function writeUtimes(accountId, filepath, node) {
    try {
        const now = new Date();
        const atime = node.createdAt ? new Date(node.createdAt) : now;
        const mtime = node.updatedAt ? new Date(node.updatedAt) : now;
        await fs_extra_1.default.utimes(filepath, atime, mtime);
    }
    catch (err) {
        (0, fileSystemErrors_1.throwFileSystemError)(err, {
            filepath,
            accountId,
            write: true,
        });
    }
}
exports.writeUtimes = writeUtimes;
async function skipExisting(filepath, overwrite = false) {
    if (overwrite) {
        return false;
    }
    if (await fs_extra_1.default.pathExists(filepath)) {
        return true;
    }
    return false;
}
const filemapperCallbackKeys = ['skippedExisting', 'wroteFolder'];
async function fetchAndWriteFileStream(accountId, srcPath, filepath, mode, options = {}, logCallbacks) {
    const logger = (0, logger_1.makeTypedLogger)(logCallbacks);
    if (typeof srcPath !== 'string' || !srcPath.trim()) {
        return;
    }
    if (await skipExisting(filepath, options.overwrite)) {
        logger('skippedExisting', `${i18nKey}.skippedExisting`, { filepath });
        return;
    }
    if (!(0, path_2.isAllowedExtension)(srcPath)) {
        (0, standardErrors_1.throwErrorWithMessage)(`${i18nKey}.errors.invalidFileType`, { srcPath });
    }
    let node;
    try {
        node = await (0, fileMapper_1.fetchFileStream)(accountId, srcPath, filepath, getFileMapperQueryValues(mode, options));
    }
    catch (err) {
        (0, standardErrors_1.throwError)(err);
    }
    await writeUtimes(accountId, filepath, node);
}
// Writes an individual file or folder (not recursive).  If file source is missing, the
//file is fetched.
async function writeFileMapperNode(accountId, filepath, node, mode, options = {}, logCallbacks) {
    const logger = (0, logger_1.makeTypedLogger)(logCallbacks);
    const localFilepath = (0, path_2.convertToLocalFileSystemPath)(path_1.default.resolve(filepath));
    if (await skipExisting(localFilepath, options.overwrite)) {
        logger('skippedExisting', `${i18nKey}.skippedExisting`, {
            filepath: localFilepath,
        });
        return true;
    }
    if (!node.folder) {
        try {
            await fetchAndWriteFileStream(accountId, node.path, localFilepath, mode, options, logCallbacks);
            return true;
        }
        catch (err) {
            return false;
        }
    }
    try {
        await fs_extra_1.default.ensureDir(localFilepath);
        logger('wroteFolder', `${i18nKey}.wroteFolder`, {
            filepath: localFilepath,
        });
    }
    catch (err) {
        (0, fileSystemErrors_1.throwFileSystemError)(err, {
            filepath: localFilepath,
            accountId,
            write: true,
        });
        return false;
    }
    return true;
}
function isTimeout(err) {
    return !!err && (err.status === 408 || err.code === 'ESOCKETTIMEDOUT');
}
async function downloadFile(accountId, src, destPath, mode, options = {}, logCallbacks) {
    const logger = (0, logger_1.makeTypedLogger)(logCallbacks);
    const { isFile, isHubspot } = getTypeDataFromPath(src);
    try {
        if (!isFile) {
            (0, standardErrors_1.throwErrorWithMessage)(`${i18nKey}.errors.invalidRequest`, { src });
        }
        const dest = path_1.default.resolve(destPath);
        const cwd = (0, path_2.getCwd)();
        let filepath;
        if (dest === cwd) {
            // Dest: CWD
            filepath = path_1.default.resolve(cwd, path_1.default.basename(src));
        }
        else if (isPathToFile(dest)) {
            // Dest: file path
            filepath = path_1.default.isAbsolute(dest) ? dest : path_1.default.resolve(cwd, dest);
        }
        else {
            // Dest: folder path
            const name = path_1.default.basename(src);
            filepath = path_1.default.isAbsolute(dest)
                ? path_1.default.resolve(dest, name)
                : path_1.default.resolve(cwd, dest, name);
        }
        const localFsPath = (0, path_2.convertToLocalFileSystemPath)(filepath);
        await fetchAndWriteFileStream(accountId, src, localFsPath, mode, options, logCallbacks);
        await queue.onIdle();
        logger('completedFetch', `${i18nKey}.completedFetch`, {
            src,
            version: getAssetVersionIdentifier(options.assetVersion, src),
            dest,
        });
    }
    catch (err) {
        const error = err;
        if (isHubspot && isTimeout(error)) {
            (0, standardErrors_1.throwErrorWithMessage)(`${i18nKey}.errors.assetTimeout`, {}, error);
        }
        else {
            (0, standardErrors_1.throwErrorWithMessage)(`${i18nKey}.errors.failedToFetchFile`, { src, dest: destPath }, error);
        }
    }
}
async function fetchFolderFromApi(accountId, src, mode, options = {}, logCallbacks) {
    const logger = (0, logger_1.makeTypedLogger)(logCallbacks);
    const { isRoot, isFolder, isHubspot } = getTypeDataFromPath(src);
    if (!isFolder) {
        (0, standardErrors_1.throwErrorWithMessage)(`${i18nKey}.errors.invalidFetchFolderRequest`, {
            src,
        });
    }
    try {
        const srcPath = isRoot ? '@root' : src;
        const queryValues = getFileMapperQueryValues(mode, options);
        const node = isHubspot
            ? await (0, fileMapper_1.downloadDefault)(accountId, srcPath, queryValues)
            : await (0, fileMapper_1.download)(accountId, srcPath, queryValues);
        logger('folderFetch', `${i18nKey}.folderFetch`, { src, accountId });
        return node;
    }
    catch (err) {
        const error = err;
        if (isHubspot && isTimeout(error)) {
            (0, standardErrors_1.throwErrorWithMessage)(`${i18nKey}.errors.assetTimeout`, {}, error);
        }
        else {
            (0, standardErrors_1.throwError)(error);
        }
    }
}
exports.fetchFolderFromApi = fetchFolderFromApi;
async function downloadFolder(accountId, src, destPath, mode, options = {}, logCallbacks) {
    const logger = (0, logger_1.makeTypedLogger)(logCallbacks);
    try {
        const node = await fetchFolderFromApi(accountId, src, mode, options, logCallbacks);
        if (!node) {
            return;
        }
        const dest = path_1.default.resolve(destPath);
        const rootPath = dest === (0, path_2.getCwd)()
            ? (0, path_2.convertToLocalFileSystemPath)(path_1.default.resolve(dest, node.name))
            : dest;
        let success = true;
        recurseFolder(node, (childNode, filepath) => {
            queue.add(async () => {
                const succeeded = await writeFileMapperNode(accountId, filepath || '', childNode, mode, options, logCallbacks);
                if (succeeded === false) {
                    success = false;
                }
            });
            return success;
        }, rootPath);
        await queue.onIdle();
        if (success) {
            logger('completedFolderFetch', `${i18nKey}.completedFolderFetch`, {
                src,
                version: getAssetVersionIdentifier(options.assetVersion, src),
                dest,
            });
        }
        else {
            (0, standardErrors_1.throwErrorWithMessage)(`${i18nKey}.errors.incompleteFetch`, { src });
        }
    }
    catch (err) {
        (0, standardErrors_1.throwErrorWithMessage)(`${i18nKey}.errors.failedToFetchFolder`, { src, dest: destPath }, err);
    }
}
/**
 * Fetch a file/folder and write to local file system.
 *
 * @async
 * @param {FileMapperInputArguments} input
 * @returns {Promise}
 */
async function downloadFileOrFolder(accountId, src, dest, mode, options = {}, logCallbacks) {
    if (!src) {
        return;
    }
    const { isFile } = getTypeDataFromPath(src);
    if (isFile) {
        await downloadFile(accountId, src, dest, mode, options, logCallbacks);
    }
    else {
        await downloadFolder(accountId, src, dest, mode, options, logCallbacks);
    }
}
exports.downloadFileOrFolder = downloadFileOrFolder;
