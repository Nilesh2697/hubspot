"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const moment_1 = __importDefault(require("moment"));
const urls_1 = require("../lib/urls");
const environment_1 = require("../lib/environment");
const logger_1 = require("../utils/logger");
const getAccountIdentifier_1 = require("../utils/getAccountIdentifier");
const auth_1 = require("../constants/auth");
const standardErrors_1 = require("../errors/standardErrors");
const i18nKey = 'models.OAuth2Manager';
class OAuth2Manager {
    account;
    writeTokenInfo;
    refreshTokenRequest;
    constructor(account, writeTokenInfo) {
        this.writeTokenInfo = writeTokenInfo;
        this.refreshTokenRequest = null;
        this.account = account;
        if (this.account.env) {
            this.account.env = (0, environment_1.getValidEnv)(this.account.env, '');
        }
    }
    async accessToken() {
        if (!this.account.auth.tokenInfo?.refreshToken) {
            (0, standardErrors_1.throwErrorWithMessage)(`${i18nKey}.errors.missingRefreshToken`, {
                accountId: (0, getAccountIdentifier_1.getAccountIdentifier)(this.account),
            });
        }
        if (!this.account.auth.tokenInfo?.accessToken ||
            (0, moment_1.default)()
                .add(5, 'minutes')
                .isAfter((0, moment_1.default)(this.account.auth?.tokenInfo.expiresAt))) {
            await this.refreshAccessToken();
        }
        return this.account.auth?.tokenInfo.accessToken;
    }
    async fetchAccessToken(exchangeProof) {
        (0, logger_1.debug)(`${i18nKey}.fetchingAccessToken`, {
            accountId: (0, getAccountIdentifier_1.getAccountIdentifier)(this.account),
            clientId: this.account.auth.clientId || '',
        });
        try {
            const { data } = await axios_1.default.post(`${(0, urls_1.getHubSpotApiOrigin)((0, environment_1.getValidEnv)(this.account.env))}/oauth/v1/token`, {
                form: exchangeProof,
                json: true,
            });
            this.refreshTokenRequest = data;
            const { refresh_token: refreshToken, access_token: accessToken, expires_in: expiresIn, } = data;
            if (!this.account.auth.tokenInfo) {
                this.account.auth.tokenInfo = {};
            }
            this.account.auth.tokenInfo.refreshToken = refreshToken;
            this.account.auth.tokenInfo.accessToken = accessToken;
            this.account.auth.tokenInfo.expiresAt = (0, moment_1.default)()
                .add(Math.round(parseInt(expiresIn) * 0.75), 'seconds')
                .toString();
            if (this.writeTokenInfo) {
                (0, logger_1.debug)(`${i18nKey}.updatingTokenInfo`, {
                    accountId: (0, getAccountIdentifier_1.getAccountIdentifier)(this.account),
                    clientId: this.account.auth.clientId || '',
                });
                this.writeTokenInfo(this.account.auth.tokenInfo);
            }
            this.refreshTokenRequest = null;
        }
        catch (e) {
            this.refreshTokenRequest = null;
            (0, standardErrors_1.throwError)(e);
        }
    }
    async exchangeForTokens(exchangeProof) {
        try {
            if (this.refreshTokenRequest) {
                (0, logger_1.debug)(`${i18nKey}.refreshingAccessToken`, {
                    accountId: (0, getAccountIdentifier_1.getAccountIdentifier)(this.account),
                    clientId: this.account.auth.clientId || '',
                });
                await this.refreshTokenRequest;
            }
            else {
                await this.fetchAccessToken(exchangeProof);
            }
        }
        catch (e) {
            const error = e;
            if (error.response) {
                (0, standardErrors_1.throwAuthErrorWithMessage)(`${i18nKey}.errors.auth`, {
                    token: error.response.data.message || '',
                }, error);
            }
            else {
                (0, standardErrors_1.throwError)(error);
            }
        }
    }
    async refreshAccessToken() {
        const refreshTokenProof = {
            grant_type: 'refresh_token',
            client_id: this.account.auth.clientId,
            client_secret: this.account.auth.clientSecret,
            refresh_token: this.account.auth.tokenInfo?.refreshToken,
        };
        await this.exchangeForTokens(refreshTokenProof);
    }
    toObj() {
        return {
            env: this.account.env,
            clientSecret: this.account.auth.clientSecret,
            clientId: this.account.auth.clientId,
            scopes: this.account.auth.scopes,
            tokenInfo: this.account.auth.tokenInfo,
            name: this.account.name,
            accountId: (0, getAccountIdentifier_1.getAccountIdentifier)(this.account),
        };
    }
    static fromConfig(accountConfig, writeTokenInfo) {
        return new OAuth2Manager({
            ...accountConfig,
            authType: auth_1.AUTH_METHODS.oauth.value,
            auth: accountConfig.auth || {},
        }, writeTokenInfo);
    }
}
exports.default = OAuth2Manager;
