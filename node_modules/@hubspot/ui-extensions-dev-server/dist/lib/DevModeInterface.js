"use strict";
/* hs-eslint ignored failing-rules */
/* eslint-disable hubspot-dev/no-unsupported-ts-syntax */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const dev_1 = require("./dev");
const constants_1 = require("./constants");
const config_1 = require("./config");
// @ts-expect-error no type defs
const logger_1 = require("@hubspot/cli-lib/logger");
const DevServerState_1 = require("./DevServerState");
const utils_1 = require("./utils");
class DevModeInterface {
    _generateAppExtensionMappings(components) {
        // Loop over all of the app configs that are passed in
        const allComponentNames = Object.keys(components);
        return allComponentNames.reduce((appExtensionMappings, componentName) => {
            var _a, _b;
            const component = components[componentName];
            if (!((_b = (_a = component.config.extensions) === null || _a === void 0 ? void 0 : _a.crm) === null || _b === void 0 ? void 0 : _b.cards)) {
                return appExtensionMappings; // It's not an app
            }
            // Load all of the extension configs for a particular app.json file
            const extensionsConfigForApp = (0, config_1.loadExtensionConfig)(component.config, component.path);
            const extensionConfigKeys = Object.keys(extensionsConfigForApp);
            // Loop over the loaded extension configs and generate the list of choices to use to prompt the user for input
            extensionConfigKeys.forEach(extensionKey => {
                const extensionConfig = extensionsConfigForApp[extensionKey];
                appExtensionMappings.push({
                    name: `${componentName}/${extensionConfig.data.title}`,
                    value: extensionConfig,
                });
            });
            return appExtensionMappings;
        }, []);
    }
    _getPlatformVersion(projectConfig) {
        const { platformVersion } = projectConfig !== null && projectConfig !== void 0 ? projectConfig : {};
        if (!platformVersion) {
            return constants_1.PLATFORM_VERSION.V20231;
        }
        switch (platformVersion) {
            case constants_1.PLATFORM_VERSION.V20231:
                return constants_1.PLATFORM_VERSION.V20231;
            case constants_1.PLATFORM_VERSION.V20232:
                return constants_1.PLATFORM_VERSION.V20232;
            default:
                return (0, utils_1.throwUnhandledPlatformVersionError)(platformVersion);
        }
    }
    setup({ components, debug = false, extensionConfig, onUploadRequired, promptUser, }) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, logger_1.setLogLevel)(debug ? logger_1.LOG_LEVEL.DEBUG : logger_1.LOG_LEVEL.LOG);
            this.onUploadRequired = onUploadRequired;
            if (extensionConfig) {
                this.configs = [extensionConfig];
                return;
            }
            const choices = this._generateAppExtensionMappings(components);
            if (choices.length === 0) {
                throw new Error('No extensions to run');
            }
            else if (choices.length === 1) {
                this.configs = [choices[0].value];
            }
            else {
                const answers = yield promptUser({
                    type: 'checkbox',
                    name: 'extensions',
                    message: 'Which extension(s) would you like to run?',
                    validate: input => {
                        if (!input || input.length === 0) {
                            return 'Select at least one extension to run';
                        }
                        return true;
                    },
                    choices,
                });
                this.configs = answers.extensions;
            }
        });
    }
    // The contract is for this to be async, so eslint can chill
    // eslint-disable-next-line require-await
    fileChange(filePath, __event) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.devServerState || !this.devServerState.extensionsMetadata) {
                return;
            }
            const relevantConfigFileChanged = this.devServerState.extensionsMetadata.some(metadata => metadata.config.extensionConfigPath === filePath);
            if (relevantConfigFileChanged && this.onUploadRequired) {
                this.onUploadRequired();
            }
        });
    }
    start({ accountId, debug, httpClient, projectConfig }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (debug !== undefined) {
                (0, logger_1.setLogLevel)(debug ? logger_1.LOG_LEVEL.DEBUG : logger_1.LOG_LEVEL.LOG);
            }
            this.devServerState = new DevServerState_1.DevServerState({
                extensionConfigs: this.configs,
                accountId,
                httpClient,
                platformVersion: this._getPlatformVersion(projectConfig),
            });
            this.shutdown = yield (0, dev_1.startDevMode)(this.devServerState);
            this.devServerState.extensionsMetadata.forEach(metadata => {
                const { config: { data: { title, appName }, }, } = metadata;
                logger_1.logger.info(`Running extension '${title}' from app '${appName}'`);
            });
        });
    }
    cleanup() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.shutdown) {
                yield this.shutdown();
            }
        });
    }
}
exports.default = new DevModeInterface();
